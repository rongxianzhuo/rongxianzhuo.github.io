
<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
	<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>HelloWorld-帮助文档</title>
	
	<!-- Animate.css -->
	<link rel="stylesheet" href="css/animate.css">
	<!-- Icomoon Icon Fonts-->
	<link rel="stylesheet" href="css/icomoon.css">
	<!-- Simple Line Icons -->
	<link rel="stylesheet" href="css/simple-line-icons.css">
	<!-- Magnific Popup -->
	<link rel="stylesheet" href="css/magnific-popup.css">
	<!-- Theme Style -->
	<link rel="stylesheet" href="css/style.css">
	<!-- Modernizr JS -->
	<script src="js/modernizr-2.6.2.min.js"></script>
	<!-- FOR IE9 below -->
	<!--[if lt IE 9]>
	<script src="js/respond.min.js"></script>
	<![endif]-->

	</head>
	<body>
	
	<div id="fh5co-main">
		<div class="fh5co-intro text-center">
			<div class="container">
				<div class="row">
					<div class="col-md-8 col-md-offset-2">
						<h1 class="intro-lead">HelloWorld帮助文档</h1>
					</div>
				</div>
			</div>
		</div>

		<div id="fh5co-content">
			<div class="container">
				<div class="row">
					<div class="col-md-12">
						<div class="row">
							<div class="col-md-12">
							
							    <h2>提示</h2>
								<p>
								    在使用手机浏览的时候建议关掉“适应屏幕”选项。该文档只适用于3.5以上版本。
								</p>
							
							    <h2>简介</h2>
								<p>
								    HelloWorld是一款解释器工具类App （以下简称App），它能让用户编辑并运行一段脚本语言。
									这个脚本语言有点像Java，支持简单的类的使用。它的语法大致上就是在Java的基础上去掉了数据类型的定义。
									如果你学习过Java语言，或许通过App上的示例就可以完全掌握HelloWorld的语法。
								</p>
								
							    <h2>名词解释</h2>
								<p>
								    类库：每一个App拥有一个类库，用户可以在类库中保存若干个不重名的类。
									它的作用是让我们保存一些常用类，以便在今后的程序中只需要通过import命令就可以将类导入而不用重新实现。
								</p>
								<p>
								    解释器原生类：解释器自带的类称为解释器原生类，包括：Null, Boolean, Char, Byte, Number, String, List。
									它们是最基础的类，在所有程序中都可以使用这七个类，它们不能通过import导入。
									要注意的是这也意味着你不能创建与他们同名的类。
								</p>
								<p>
								    应用原生类：App自带的，不是用App编写出来的类称为应用原生类。
									目前包括：Pattern，Matcher，Math，System，HFile，HttpUtils，JSONObject，JSONArray。它们需要通过import命令进行导入才能使用。
									不建议在类库中创建与它们同名的类。创建应用原生类的作用除了提供应用或设备特有的操作（如网络和文件操作）外，还能以更快的速度执行代码。
								</p>
								<p>
								    程序：程序是App可以运行的基本单元，由一个或多个类组成。
								</p>
								
							    <h2>基本用法</h2>
								<p>
								    在编写程序的时候有一些基本规则，除了不要定义非法或重复的类名外，所有的包括import的类至少要有一个类拥有入口方法main()，它的定义方法如下：
								</p>
								<pre>
static main() {
    //程序执行的第一行代码
}
								</pre>
								<p>
								    按照惯例，写一个HelloWorld程序
								</p>
								<pre>
import System;
class Program  {
    static main() {
        System.print("hello, world");
    }
}
								</pre>
								
							    <h2>变量</h2>
								<p>
								    变量可以保存数值，它在代码中的表现形式是一个合法的变量名。
								</p>
								<p>
								    变量名必须由下划线、数字和字母组成且开头不能是数字。
								</p>
								<p>
								    变量名不能是关键字，目前关键字包括：{"while", "if", "break", "return", "continue", "class", "else", "static", "import", "for", "null", "this"}。
								</p>
								<p>
								    程序中所有要引用的类名也不能成为变量名。
								</p>
								
							    <h2>作用域</h2>
								<p>
								    所有变量都有作用域，作用域是变量所在的代码块内，一般的，一对大括号包含一个代码块。
								</p>
								<pre>
class Person {
    age;
    name;
    Person(mName) {
        //这里就是一个代码块，
        i = 0;
        while (true) {
            //这又是一个代码块，但是还在i的作用于内
            j = 0;
        }
        //此处离开了j的作用域，即便你尝试使用它也只能是一个新的变量。

        while (true) j = 0;//这里其实省略了大括号，这个循环代码块只有一行 j = 0;
        //此处也离开了j的作用域。
    }
}
								</pre>
								<p>
								    如果一个变量如果没有进行初始化，变量的值为null。
								</p>
								
							    <h2>对象（类）</h2>
								<p>
								    程序由类组成，就像现实世界有很多对象组成。一个对象有各种属性和方法。例如：一个人是一个对象，有性别和年龄属性，有走路和说话的方法。
								</p>
								
							    <h4>类定义的格式</h4>
								<pre>
class 变量名 {
    //里面声明成员变量和方法
}
								</pre>
								<p>
								    例如：
								</p>
								<pre>
class Person {
    age;//年龄

    //跑步方法
    run() {
    }
}
								</pre>
								<p>
								    值得注意的是：一个类的成员变量名不能重复，方法名可以重复，但是拥有相同方法名的方法的参数个数不能相同。
								</p>
								
							    <h4>成员变量</h4>
								<p>
								    定义格式：
								</p>
								<pre>
变量名;
变量名 = 表达式;
								</pre>
								<p>
								    例如：
								</p>
								<pre>
class Person {
    age;
    friendly = true;
}
								</pre>
								
							    <h4>成员方法</h4>
								<p>
								    定义格式：
								</p>
								<pre>
变量名(0个或多个以逗号','分隔的变量名) {
    //代码
}
								</pre>
								<p>
								    例如：
								</p>
								<pre>
class Person {
    run() {
    }
    run(point1, point2) {
    }
    speak(sentence) {
        System.print(sentence);
    }
}
								</pre>
								<p>
								    所有的方法都有返回值，默认返回null。可以通过'return'关键字返回，例如：
								</p>
								<pre>
class Person {
    name;
    getName() {
        return name;
    }
}
								</pre>
								
							    <h4>静态成员与方法</h4>
								<p>
								    静态成员不具体介绍，定义方法是在成员定义前加上 'static' 关键字。
								</p>
								<pre>
static age = 0;
static main() {
}
								</pre>
								
							    <h4>构造类的实例</h4>
								<p>
								    如果一个成员方法的方法名与类名相同，这样的方法称为构造方法，它的返回值是一个类的实例。我们可以在构造方法中初始化各个成员变量。
								</p>
								<pre>
class Person {
    name;
    Person(name) {
        this.name = name;
    }
}
class Demo {
    static main() {
        man = Person("小明");//构造了一个名字为小明的Person实例并赋值给man变量
    }
}
								</pre>
								<p>
								    和Java不同，这里调用构造方法是没有 new 关键字的。
								</p>
								
							    <h4>成员变量的引用</h4>
								<p>
								    在同一个实例内，一个成员方法可以直接通过变量名直接引用同一个实例的成员变量或方法，如果不在同一个实例内则需要通过'.'操作符进行引用，
									如果方法的参数名和成员变量的变量名重复，需要通过this关键字引用成员变量。 示例：
								</p>
								<pre>
import System;
class Person {
    friendly;
    age;
    Person(age) {
        this.age = age;
        friendly = true;
    }
    Person(age, friendly) {
        this.age = age;
        this.friendly = friendly;
    }
}
class Demo {
    static main() {
        man = Person(18);
        System.print(man.friendly);
    }
}
								</pre>
							
							    <h2>原生类文档</h2>
								<p>
								    下面介绍所有原生类的方法，方法名后面的括号内的数字代表参数个数。
								</p>
								
							    <h4>Number 类</h4>
								<pre>
toInteger(0);//获得数字强转为整型的结果
								</pre>
								
							    <h4>String 类</h4>
								<pre>
String(0);//创建一个空字符串实例
String(1);//创建一个字符串实例，参数是字节 List
length(0);//同Java中的String.length();
equals(1);//与java中String.equals(Object)方法差不多
getBytes(0);//与java中String.getBytes()方法差不多，不过返回的是 List
contains(1);//字符串是否包含有参数所代表的子字符串
isNumber(0);//返回字符串是否是一个数字
toNumber(0);//返回字符串所表示的数字，如果出现异常则返回null
substring(1);//同Java中的String.substring(int);
substring(2);//同Java中的String.substring(int, int);
startsWith(1);//同Java中的String.startsWith(int);
endsWith(1);//同Java中的String.endsWith(int);
								</pre>
								
							    <h4>List 类</h4>
								<p>
								    列表 它支持用 '[]' 来操作，如： l = [];//创建空链表 l = [1, 'c', "string"];//创建有初始值的链表 l[1] = 998;//设置链表的某项
								</p>
								<pre>
List(0);//构造函数
get(1);//获取链表中某项，参数为下标，从0开始
remove(1);//移除链表中某项，参数为下标，从0开始
size(0);//获取链表长度
add(1);//向链表尾部增加新的一项
								</pre>
								
							    <h4>Pattern 类</h4>
								<p>
								    正则表达式Pattern类
								</p>
								<pre>
Pattern(1);//构造函数，同Java 的 Pattern.compile(String)
Pattern(2);//构造函数，同上，但是第二个参数是布尔型，代表是否忽略大小写
matcher(1);//同Java 的 Pattern.matcher(String)方法，返回一个Matcher实例
								</pre>
								
							    <h4>Matcher 类</h4>
								<p>
								    正则表达式Matcher类
								</p>
								<pre>
group(0);//同Java 的 Matcher.group()
group(1);//同Java 的 Matcher.group(int)
find(0);//同Java 的 Matcher.find();
								</pre>
								
							    <h4>System 类</h4>
								<p>
								    系统类
								</p>
								<pre>
static input(0);//等待并返回用户输入的字符串
static print(1);//打印一个字符串，参数就是要打印的字符串
static printWebImage(1);//打印一个网络图片，参数是url
static toast(1);//显示一个短暂的信息提示，参数是要显示的字符串
static startAnimActivity(3);//进入动画显示界面，第一个参数是一个实现的loadScene(0)方法的实例，loadScene(0)必须返回一个Scene实例，第二个参数是动画界面宽度（像素），第三个是动画界面高度（像素）
								</pre>
								
							    <h4>File 类</h4>
								<p>
								    手机文件类
								</p>
								<pre>
File(1);//构造方法，参数是文件路径
getName(0);//获取文件名
getPath(0);//获取文件路径
listFiles(0);//如果是文件夹，返回文件夹下所有的文件 List
isDirectory(0);//返回这个文件是否是文件夹
static getPhoneDirectory(0);//获取手机存储目录名
rename(1);//文件或文件夹重命名，参数是目标文件名，返回是否成功
delete(0);//删除文件或空目录，返回是否成功
								</pre>
								
							    <h4>HttpUtils 类</h4>
								<p>
								    网络访问工具类
								</p>
								<pre>
static getString(1);//获取访问所得字符串，具体参考 com.squareup.okhttp.Response.body().string();
static downloadFile(2);//下载一个网络文件，第一个参数是url，第二个是完整的目标文件路径，返回是否成功。因为还没有完善的下载管理，建议下载小文件。
								</pre>
								
							    <h4>JSONObject 类</h4>
								<pre>
JSONObject(1);//构造函数，同Java 的 JSONObject(String)
getString(1);//同Java 的 JSONObject.getString(String)
getNumber(1);//同Java 的 JSONObject.getDouble(String)
getJSONObject(1);//同Java 的 JSONObject.getJSONObject(String)
getJSONArray(1);//同Java 的 JSONObject.getJSONArray(String)
								</pre>
								
							    <h4>JSONArray 类</h4>
								<pre>
JSONArray(1);//构造函数，同Java 的 JSONArray(String)
getString(1);//同Java 的 JSONObject.getString(int)
getNumber(1);//同Java 的 JSONObject.getDouble(int)
getJSONObject(1);//同Java 的 JSONObject.getJSONObject(int)
getJSONArray(1);//同Java 的 JSONObject.getJSONArray(int)
length(0);//同Java 的 JSONObject.length()
								</pre>
								
							    <h4>Scene 类</h4>
								<p>
								    场景类，在动画界面使用，在动画界面运行时出现的异常目前无法得到显示。
								</p>
								<pre>
Scene(0);//构造函数
addEntity(1);//向该场景添加一个物体，目前只支持Line、和Rect两种
setBackground(3);//设置场景背景颜色，三个参数从左到右分别是红绿蓝分量，取值范围是0~1
setUpdateHandler(1);//设置刷新监听器，参数是实现了onUpdate(0)方法的实例，动画引擎每一帧开始都会调用onUpdate(0)方法
setOnClickListener(1);//设置单击监听器，参数是实现了onClick(2)方法的实例，用户每一次点击场景系统都会调用onClick(2)方法，onClick(2)方法的两个参数分别是点击的x坐标和y坐标
								</pre>
								
							    <h4>Line 类</h4>
								<p>
								    线段类，可以作为Entity加入场景
								</p>
								<pre>
Line(x1, y1, x2, y2, width);//构造函数，至少在loadScene接口执行后才能构造矩形实例
setColor(r, g, b);//设置颜色
setPosition(x1, y1, x2, y2);//设置位置
getX1(0);
getY1(0);
getX2(0);
getY2(0);
getWidth(0);
setVisible(1);设置是否可见
								</pre>
								
							    <h4>Rectangle 类</h4>
								<p>
								    矩形类，可以作为Entity加入场景
								</p>
								<pre>
Rectangle(x1, y1, width, height);//构造函数，至少在loadScene接口执行后才能构造矩形实例
setColor(r, g, b);//设置颜色
setPosition(x, y);//设置位置
getX(0);
getY(0);
getWidth(0);
getHeight(0);
setVisible(1);设置是否可见
								</pre>
								
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>

	</div>
	<footer id="fh5co-footer">
		<div class="container">
			<div class="row">
				<div class="col-md-10 col-md-offset-1 text-center">
					<p>---------------------------------------------------</p>
				</div>
			</div>
		</div>
	</footer>


	<!-- jQuery -->
	<script src="js/jquery.min.js"></script>
	<!-- jQuery Easing -->
	<script src="js/jquery.easing.1.3.js"></script>
	<!-- Bootstrap -->
	<script src="js/bootstrap.min.js"></script>
	<!-- Waypoints -->
	<script src="js/jquery.waypoints.min.js"></script>
	<!-- Magnific Popup -->
	<script src="js/jquery.magnific-popup.min.js"></script>
	<!-- Main JS -->
	<script src="js/main.js"></script>

	
	</body>
</html>
